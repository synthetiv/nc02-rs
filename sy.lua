-- ??? (nc02-rs)
-- @synthetivv
--
-- we can bring to birth
-- a new world from the
-- ashes of the old

sc = softcut

next_head = 1

regularity = 0

echo_rates = { 1/48, 1/32, 1/24, 1/16, 1/12, 1/8, 1/6, 1/4, 1/3, 1/2 }

step_px = 4
history_length = 64

sway_length = 172
sway = {}
for y = 1, sway_length do
  sway[y] = math.sin(2 * math.pi * y / sway_length)
end
sway_offset = 0

wind_direction = 0
wind_direction_smooth = 0

--[[
onsets = { -- generated by `aubioonset -t 0.66 -O energy nc02-perc.wav`
  0.000000, 0.427479, 0.495688, 0.999646, 1.496604,
  1.993625, 2.499792, 2.996063, 3.089292, 3.191354,
  3.465250, 4.338583, 4.519729, 4.594812, 4.680313,
  4.745062, 4.915563, 4.995354, 5.134729, 5.343125,
  5.981979, 6.270688, 6.463500, 6.521500, 6.780729,
  7.289479, 7.353229, 7.497542, 7.615104, 7.698021,
  7.857584, 7.950875, 8.077105, 8.157979, 8.261771,
  8.419791, 8.547334, 8.718875,
  10, 11, 12, 13
}
--]]

-- instruments

inst_base = {
  level = 1,
  pan = 0,
  rate = 0.5,
  decay = 1,
  echo = 0.3,
  comp_send = 0.7,
  comp = false,
  x = 64,
  p_trig = 1,
  p_shift = 0,
  p_reset = 1
}

inst_metatable = {
  __call = function(self, new)
    return inst(new, self)
  end
}

function inst(t, proto)
  for k, v in pairs(proto or inst_base) do
    if t[k] == nil then
      t[k] = v
    end
  end
  return setmetatable(t, inst_metatable)
end

bd = inst{
  start = 3.465250,
  length = 0.225,
  pan = 0,
  rate = 0.37,
  decay = 0.97,
  echo = 0.1,
  x = 62
}
hd = bd{
  rate = 0.44,
  x = 70
}

ch = inst{
  start = 1.496604,
  length = 0.25,
  pan = -0.2,
  rate = 0.5,
  level = 0.45,
  decay = 0.7,
  echo = 0.2,
  x = 56
}
oh = ch{
  decay = 1,
  x = 48
}

hc = inst{
  start = 0,
  length = 0.25,
  pan = 0.3,
  rate = 0.5,
  level = 0.7,
  echo = 0.6,
  x = 78
}

sd = inst{
  start = 0.999646,
  length = 0.25,
  pan = 0.2,
  level = 0.7,
  decay = 0.98,
  echo = 0.7,
  x = 32
}

n1 = inst{
  start = 13.5,
  length = 11,
  pan = -0.1,
  level = 0.2,
  echo = 0.2,
  comp_send = 0,
  comp = true,
  x = 40
}
n2 = n1{
  start = 11,
  pan = 0.1,
  rate = 1,
  echo = 0.1,
  x = 86
}

z1 = inst{
  start = 23,
  length = 5,
  pan = 0.4,
  rate = 0.25,
  level = 0.7,
  decay = 1,
  echo = 0.3,
  comp_send = 0,
  comp = true,
  x = 94
}
z2 = z1{
  start = 24,
  length = 4
}
z3 = z1{
  start = 25,
  length = 3
}
z4 = z1{
  start = 26,
  length = 2
}
z5 = z1{
  start = 27,
  length = 1
}

za = inst{
  start = 28.25,
  length = 4,
  pan = -0.4,
  rate = 0.25,
  level = 0.7,
  echo = 0.3,
  comp_send = 0,
  comp = true,
  x = 24
}
zb = za{
  start = 29.25,
  length = 3
}
zc = za{
  start = 30.25,
  length = 2
}
zd = za{
  start = 31.25,
  length = 1
}

sidechain_input = 0
sidechain_input_smooth = 0
sidechain_release = 0.04
sidechain_level = 1
sidechain_depth = 1.2

Voice = {}
Voice.__index = Voice
function Voice.new(buffer)
  local v = setmetatable({}, Voice)
  local head = next_head
  next_head = head + 1

  sc.enable(head, 1)
  sc.buffer(head, buffer)
  sc.pan(head, 0)
  sc.level(head, 1.0)
  sc.loop(head, 0)
  sc.loop_start(head, 1)
  sc.loop_end(head, 2)
  sc.position(head, 0)
  sc.fade_time(head, 0.0025)
  sc.pan_slew_time(head, 0.0001)
  sc.level_slew_time(head, 0.01)
  sc.rate(head, 0.5 / clock.get_beat_sec())
  sc.play(head, 1)
  sc.level_slew_time(head, 0.02)

  for h = 1, 6 do
    sc.level_cut_cut(head, h, 0)
  end

  v.head = head

  return v
end

EchoVoice = {}
EchoVoice.__index = EchoVoice

function EchoVoice.new()
  local v = setmetatable(Voice.new(2), EchoVoice)
  local head = v.head
  local pan = 0
  local rate_setting = 5
  local rate = echo_rates[rate_setting]
  local decay = 0.8

  sc.loop_start(head, head)
  sc.loop_end(head, head + 0.0625)
  sc.loop(head, 1)
  sc.position(head, 1)
  sc.rate(head, rate / clock.get_beat_sec())
  sc.level(head, 1)
  sc.rec_level(head, 1)
  sc.pre_level(head, decay)
  sc.rec(head, 1)
  sc.play(head, 1)
  sc.pre_filter_dry(head, 0)
  sc.pre_filter_lp(head, 1)
  sc.pre_filter_fc(head, 10000)
  sc.pre_filter_rq(head, 1)
  sc.post_filter_dry(head, 0)
  sc.post_filter_hp(head, 1)
  sc.post_filter_fc(head, 200)
  sc.post_filter_rq(head, 1)
  sc.rate_slew_time(head, 0.3)
  sc.pan_slew_time(head, 0.3)

  v.pan = pan
  v.rate_setting = rate_setting
  v.rate = rate
  v.decay = decay

  return v
end

function EchoVoice:move(d)
  self.pan = math.max(-1, math.min(1, math.atan(self.pan + d)))
  sc.pan(self.head, self.pan)
end

function EchoVoice:update_rate()
  local deviation = (math.random() - 0.5) * 0.05
  sc.rate(self.head, self.rate * math.pow(2, deviation) / clock.get_beat_sec())
  self:move(wind_direction * 0.01 + math.random() * 0.25 - 0.125)
end

function EchoVoice:update_level()
  sc.pre_level(self.head, self.decay * sidechain_level)
  sc.level(self.head, 1 * sidechain_level)
end

PercVoice = {}
PercVoice.__index = PercVoice

function PercVoice.new()
  local v = setmetatable(Voice.new(1), PercVoice)
  v.tick = 0
  v.step_index = 1
  v.shift = 0
  v.send = 0
  v.decay_level = 0
  v.instrument = n1

  -- initialize history
  local history = {}
  for h = 1, history_length do
    history[h] = {
      time = 0,
      trig = false,
      echo = 0,
      x = 64
    }
  end
  v.history = history
  v.history_index = 1

  return v
end

function PercVoice:update_level()
  local beat_sec = clock.get_beat_sec()
  local step = self.step
  self.decay_level = self.decay_level * step.decay
  local level = step.level * self.decay_level
  if step.comp then
    level = level * sidechain_level
  end
  sc.level(self.head, level)
  sc.rate(self.head, step.rate / clock.get_beat_sec())
  for e = 1, 2 do
    sc.level_cut_cut(self.head, echoes[e].head, (self.echo == e and level or 0))
  end
  sidechain_input = sidechain_input + level * step.comp_send
end

function PercVoice:next_tick()
  self.tick = self.tick % self.pattern.length + 1

  local i = 0
  local did_trig = false
  -- maybe play step
  -- TODO: is >= needed? under what circumstances might we have jumped PAST a step?
  while (self.tick + self.shift - 1) % self.pattern.length + 1 == self.next_step.t do

    local step_index = self.next_step_index
    local step = self.next_step
    
    if not did_trig then

      -- calculate trigger probability
      local trig = math.random() < step.p_trig

      -- calculate echo send probability
      local echo = 0
      if math.random() < math.min(1, step.echo - regularity / 2) then
        echo = math.random(1, 2)
      end

      self.echo = echo
      self.step = step
      self.step_index = step_index

      -- save history step
      local history_index = self.history_index % history_length + 1
      local history_step = self.history[history_index]
      history_step.time = util.time()
      history_step.x = step.x
      history_step.trig = trig
      history_step.echo = echo
      self.history_index = history_index

      -- play?
      if trig then
        self:play()
        did_trig = true
      end
    end

    self.next_step_index = self.next_step_index % #self.pattern + 1
    self.next_step = self.pattern[self.next_step_index]
    i = i + 1
    if i >= 10 then
      error('loooop')
    end

    -- maybe reset/shift for next step
    if math.random() < math.min(1, self.next_step.p_reset + regularity) then
      self.shift = 0
    end
    if math.random() < math.min(1, self.next_step.p_shift - regularity) then
      if math.random(0, 1) == 1 then
        self.shift = self.shift + 1
      else
        self.shift = self.shift - 1
      end
    end
  end
end

function PercVoice:play()
  local step = self.step
  local head = self.head
  local start = step.start
  local length = step.length

  sc.rate(head, step.rate / clock.get_beat_sec())
  sc.loop_start(head, start)
  sc.loop_end(head, start + length)
  sc.position(head, start)
  sc.level(head, step.level)
  sc.pan(head, step.pan)
  sc.play(head, 1)
  for e = 1, 2 do
    sc.level_cut_cut(head, echoes[e].head, (self.echo == e and step.level or 0))
  end

  self.decay_level = 1
end

function PercVoice:set_pattern(pattern)
  self.pattern = pattern
  self.step_index = #pattern
  self.step = pattern[self.step_index]
  self.next_step_index = 1
  self.next_step = pattern[self.next_step_index]
  self.tick = 0
  self.shift = 0
end

echoes = {}
for e = 1, 2 do
  echoes[e] = EchoVoice.new()
end

drums = {}
for d = 1, 3 do
  drums[d] = PercVoice.new()
end

-- TODO: negative p_trig is less likely to trigger when regularity is high

drums[1]:set_pattern{
  length = 16,
  bd{ t = 1,    p_trig = 1,     p_shift = 0.25,  p_reset = 0.7  },
  hd{ t = 5,    p_trig = 0.33,  p_shift = 0.25,  p_reset = 0.5  },
  hc{ t = 7,    p_trig = 0.05,  p_shift = 0.25,  p_reset = 0.5  },
  bd{ t = 9,    p_trig = 1,     p_shift = 0.25,  p_reset = 0.7  },
  hc{ t = 13,   p_trig = 0.1,   p_shift = 0.25,  p_reset = 0.5  }
}

drums[2]:set_pattern{
  length = 8,
  ch{ t = 1,    p_trig = 0.2,   p_shift = 0,     p_reset = 1    },
  ch{ t = 3,    p_trig = 0.8,   p_shift = 0,     p_reset = 1    },
  oh{ t = 5,    p_trig = 0.2,   p_shift = 0,     p_reset = 1    },
  ch{ t = 7,    p_trig = 0.8,   p_shift = 0,     p_reset = 1    }
}

--[[
drums[3]:set_pattern{
  length = 72,
  n2{ t = 1,    n_len = 16,  p_trig = 1,    p_shift = 0,    p_reset = 0.25 },
  n1{ t = 17,   n_len = 8,   p_trig = 0.2,  p_shift = 0.1,  p_reset = 0.25 },
  n2{ t = 25,   n_len = 8,   p_trig = 0.2,  p_shift = 0,    p_reset = 0.25 },
  n2{ t = 33,   n_len = 16,  p_trig = 0.7,  p_shift = 0,    p_reset = 0.25 },
  n2{ t = 49,   n_len = 8,   p_trig = 1,    p_shift = 0,    p_reset = 0.25 },
  n1{ t = 57,   n_len = 8,   p_trig = 0.2,  p_shift = 0.1,  p_reset = 0.25 },
  n1{ t = 65,   n_len = 8,   p_trig = 0.2,  p_shift = 0.1,  p_reset = 0.25 }
}
drums[3]:set_pattern{
  length = 2
  n2{ t = 1,    n_len = 1,    p_trig = 0.7,  p_shift = 0,    p_reset = 0.25 },
  sd{ t = 2,    n_len = 0.5,  p_trig = 0.1,  p_shift = 0,    p_reset = 1 },
  n1{ t = 2.5,  n_len = 0.5,  p_trig = 0.5,  p_shift = 0,    p_reset = 0.25 }
}
drums[3]:set_pattern{
  length = 20,
  n2{ t = 1,    n_len = 4,   p_trig = 0.3,  p_shift = 0,    p_reset = 0.25 },
  sd{ t = 5,    n_len = 2,   p_trig = 0.1,  p_shift = 0,    p_reset = 1 },
  n1{ t = 7,    n_len = 6,   p_trig = 0.3,  p_shift = 0,    p_reset = 0.25 },
  sd{ t = 13,   n_len = 2,   p_trig = 0.1,  p_shift = 0,    p_reset = 1 },
  n1{ t = 15,   n_len = 6,   p_trig = 0.3,  p_shift = 0,    p_reset = 0.25 }
}
drums[3]:set_pattern{
  length = 80,
  z1{ t = 1,    n_len = 8,   p_trig = 0.2,  p_shift = 0,    p_reset = 1 },
  za{ t = 9,    n_len = 8,   p_trig = 0.2,  p_shift = 0,    p_reset = 1 },
  z2{ t = 17,   n_len = 8,   p_trig = 0.2,  p_shift = 0,    p_reset = 1 },
  zb{ t = 25,   n_len = 8,   p_trig = 0.2,  p_shift = 0,    p_reset = 1 },
  z3{ t = 33,   n_len = 8,   p_trig = 0.2,  p_shift = 0,    p_reset = 1 },
  zc{ t = 41,   n_len = 8,   p_trig = 0.2,  p_shift = 0,    p_reset = 1 },
  z4{ t = 49,   n_len = 8,   p_trig = 0.2,  p_shift = 0,    p_reset = 1 },
  zd{ t = 57,   n_len = 8,   p_trig = 0.2,  p_shift = 0,    p_reset = 1 },
  z5{ t = 65,   n_len = 16,  p_trig = 0.2,  p_shift = 0,    p_reset = 1 },
}
--]]
drums[3]:set_pattern{
  length = 77,
  z1{ t = 1,    p_trig = 0.2,   p_shift = 0,     p_reset = 1    },
  n2{ t = 5,    p_trig = 0.3,   p_shift = 0,     p_reset = 1    },
  za{ t = 9,    p_trig = 0.2,   p_shift = 0,     p_reset = 1    },
  z2{ t = 17,   p_trig = 0.2,   p_shift = 0,     p_reset = 1    },
  zb{ t = 25,   p_trig = 0.2,   p_shift = 0,     p_reset = 1    },
  n1{ t = 29,   p_trig = 0.3,   p_shift = 0,     p_reset = 1    },
  z3{ t = 33,   p_trig = 0.2,   p_shift = 0,     p_reset = 1    },
  zc{ t = 41,   p_trig = 0.2,   p_shift = 0,     p_reset = 1    },
  z4{ t = 49,   p_trig = 0.2,   p_shift = 0,     p_reset = 1    },
  zd{ t = 57,   p_trig = 0.2,   p_shift = 0,     p_reset = 1    },
  z5{ t = 65,   p_trig = 0.2,   p_shift = 0,     p_reset = 1    },
  n1{ t = 69,   p_trig = 0.3,   p_shift = 0,     p_reset = 1    },
  n2{ t = 73,   p_trig = 0.3,   p_shift = 0,     p_reset = 1    },
  sd{ t = 76,   p_trig = 0.1,   p_shift = 0,     p_reset = 1    }
}

envelope_metro = metro.init()
envelope_metro.time = 0.005
envelope_metro.event = function()
  sidechain_input = 0
  for d = 1, 3 do
    drums[d]:update_level()
  end
  for e = 1, 2 do
    echoes[e]:update_level()
  end
  if sidechain_input > sidechain_input_smooth then
    sidechain_input_smooth = sidechain_input
  else
    sidechain_input_smooth = sidechain_input_smooth + (sidechain_input - sidechain_input_smooth) * sidechain_release
  end
  sidechain_level = math.max(0, 1 - sidechain_input_smooth * sidechain_depth)
  envelope_metro.time = 0.0025 / clock.get_beat_sec()
end

redraw_metro = metro.init()
redraw_metro.time = 1/15
redraw_metro.event = function()
  redraw()
end

flutter_metro = metro.init()
flutter_metro.time = 0.3
flutter_metro.event = function()
  for e = 1, 2 do
    echoes[e]:update_rate()
  end
end

function load_file(filename, buffer, buffer_start)
  local path = _path.code .. 'nc02-rs/lib/' .. filename
  sc.buffer_read_mono(path, 0, buffer_start, -1, 1, buffer) -- -1 = read whole file
end

function init()
  load_file('nc02-perc.wav', 1, 0)
  load_file('nc02-tonal.wav', 1, 10)
  load_file('synthetivv.wav', 1, 23)
  params:set('reverb', 0)
  params:set('compressor', 0)
  -- params:set('clock_tempo', 120)

  params:add{
    id = 'regularity',
    name = 'regularity',
    type = 'control',
    controlspec = controlspec.new(-1, 1, 'lin', 0.05, 0),
    action = function(value)
      regularity = value
    end
  }

  clock.run(function()
    while true do
      clock.sync(0.25) -- 16th notes
      for d = 1, 3 do
        drums[d]:next_tick()
      end
    end
  end)

  clock.run(function()
    while true do
      clock.sync(2)
      if math.random() < 0.3 then
        for e = 1, 2 do
          local echo = echoes[e]
          local jump = (math.random() - 0.5) * 2 * (2 - regularity)
          echo.rate_setting = math.max(1, math.min(#echo_rates, math.floor(echo.rate_setting + jump + 0.5)))
          echo.rate = echo_rates[echo.rate_setting]
          echo:move(math.random() - 0.5)
        end
        wind_direction = math.random() * 2 - 1
        local stillness = math.atan(2 - math.abs(wind_direction * 2)) * 0.37
        sc.level_cut_cut(echoes[1].head, echoes[2].head, stillness)
        sc.level_cut_cut(echoes[2].head, echoes[1].head, stillness)
      end
    end
  end)

  envelope_metro:start()
  redraw_metro:start()
  flutter_metro:start()
end

function enc(n, d)
  if n == 1 then
    params:delta('output_level', d)
  elseif n == 2 then
    params:delta('clock_tempo', d)
  elseif n == 3 then
    params:delta('regularity', d)
  end
end

function get_sway(y, offset_fine, offset_coarse)
  local amount = math.max(0, 65 - y)
  local index = math.floor(y + offset_fine * 11 + offset_coarse * 37 + sway_offset + 0.5)
  local value = sway[index % sway_length + 1]
  return math.floor(amount * (value / 3 + wind_direction_smooth) + 0.5)
end

function redraw()
  screen.clear()
  local beats = clock.get_beats()
  sway_offset = (beats * 2) % sway_length
  wind_direction_smooth = wind_direction_smooth + (wind_direction - wind_direction_smooth) * 0.03
  local time = util.time()
  for d = 1, 3 do
    local drum = drums[d]
    for s = 1, history_length do
      local history_index = (drum.history_index - s) % history_length + 1
      local step = drum.history[history_index]
      local y = math.floor(64 - (time - step.time) * 40 + 0.5)
      if y > -3 then
        local x = step.x
        if step.trig then
          local level = math.max(1, math.floor(15 * math.max(0, y / 64) ^ 2 + 0.5))
          screen.level(level)
          screen.rect(x + get_sway(y, history_index, d), y, 3, 3)
          screen.fill()
          if step.echo > 0 then
            local echo_y = y + step_px + 1
            while level > 1 do
              level = level - 1
              screen.level(level)
              screen.move(x + get_sway(echo_y - step_px + 1, history_index, d), echo_y)
              screen.line_rel(3, 0)
              screen.stroke()
              echo_y = echo_y + 2
            end
          end
        else
          screen.level(1)
          screen.rect(x + 1 + get_sway(y, history_index, d), y + 1, 1, 1)
          screen.fill()
        end
      end
    end
  end
  screen.update()
end

function cleanup()
  redraw_metro:stop()
  envelope_metro:stop()
  flutter_metro:stop()
end
